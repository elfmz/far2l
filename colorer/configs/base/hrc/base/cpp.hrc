<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hrc PUBLIC "-//Cail Lomecb//DTD Colorer HRC take5//EN"
  "http://colorer.sf.net/2003/hrc.dtd">
<hrc version="take5" xmlns="http://colorer.sf.net/2003/hrc"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://colorer.sf.net/2003/hrc http://colorer.sf.net/2003/hrc.xsd">
<type name="cpp">

 <annotation>
 <documentation>
    c++ syntax description
 </documentation><contributors><![CDATA[
    Vladimir Tarasov <tsoftgroup@chat.ru>
    Timur Safin <timur@lanit.ru>
    cail: split into two schemes: c and cpp

    Eugene Efremov <4mirror@mail.ru>:
     - split c/c++ outlines
     - add temlpates
     - add STL keywords
     - change regions routing
 ]]></contributors>
 </annotation>

 <region name="KeywordSTL" parent="c:KeywordStdio"/>
 <region name="KeywordNamespace" parent="def:Prefix"/>
 <region name="ClassOutline" parent="c:StructOutline"/>
 <region name="NamespaceOutline" parent="c:StructOutline"/>

 <scheme name="Expression">

  <annotation>
   <documentation>
    Next blocks supported C++ templates
   </documentation>
   <appinfo> <todo> <![CDATA[

    Блок #1.

     It's ok.

    Блок #2.

     Hа текущий момент :

     - Распознает и игнорирует конструкции типа a<<b<<c>>d и a<c && b>d.

     - Корректно работает с констукциями типа vector<void (*)(int, int)>
       и vector<int*[],std::allocator<int*[]>>.

     - Поддерживается только 6 уровней вложения. Я не знаю, вомзожна ли
       корректная рекурсия в регэкспах, а без нее бесконечное число
       вложений невозможно (впорчем, на практике 6 и уровней темплайтов
       не встречается).

     - К сожалению, обламывается при переносах: /s не работает.

     - Глючит с  конструкциями типа a<b & b>s и if(b<c>d) - которые,
       обычно, являются ошибками.

     Вывод: проблемной, требующей исправления, остается только /s. Возможна
     ли вообще поддержка этой опции в рамках колорера?

   ]]> </todo> </appinfo>
  </annotation>

  <!-- !!EE: Block #1 template support -->
  <block start="/(template)\s*(&lt;):?!/" end="/(&gt;)&gt;?!/" scheme="Expression"
   region00="def:PairStart" region10="def:PairEnd"
   region01="c:KeywordANSI" region02="c:StructureSymbol"
   region11="c:StructureSymbol"
  />
  
  <!-- !!EE: Heuristics template search  -->
  <block start="/(class|struct|typename|typedef|public|private|protected)\s+[\w_]+(\s*(::)\s*[\w_]+)*\s*((&lt;)):?!/" 
   end="/(&gt;)&gt;?!/" scheme="Expression"
   region05="def:PairStart" region10="def:PairEnd"
   region01="c:KeywordANSI" region03="c:StructureSymbol" region04="c:StructureSymbol"
   region11="c:StructureSymbol"
  />
  
  <!-- Hack for lambdas and list initialization -->
  <block start="/(\{)/" end="/(\})/" scheme="Expression"
        region00="def:SymbolStrong" region01="def:PairStart" region10="def:SymbolStrong" region11="def:PairEnd"/>

  <!-- !!EE: Block #2 template support -->
  <!-- Colorer 4:
  <block start="/([\w\s])?#1(&lt;)(&lt;)?!
     ((([\w_\s\*\n\r,:])|(&amp;(&amp;)?!)|
     (&lt;(([\w_\s\*\n\r,:])|(&amp;(&amp;)?!)|
     (&lt;(([\w_\s\*\n\r,:])|(&amp;(&amp;)?!)|
     (&lt;(([\w_\s\*\n\r,:])|(&amp;(&amp;)?!)|
     (&lt;(([\w_\s\*\n\r,:])|(&amp;(&amp;)?!)|
     (&lt;(([\w_\s\*\n\r,:])|(&amp;(&amp;)?!))*&gt;)
     )*&gt;))*&gt;))*&gt;))*&gt;))*&gt;)?=/xs"
   end="/(&gt;)/" scheme="cpp"
   region00="dpOpenStruct" region10="dpCloseStruct"
   region02="dSymbol2" region11="dSymbol2"/>-->
   <!-- \(\)\[\] -->
  <block scheme="Expression">
   <start region0="def:PairStart" region2="c:StructureSymbol">
    <![CDATA[
     /([\w\s])?#1
      (<)(<)?!\M
       ([\w_\s\*\(\)\[\],:]|&(&)?!|<:?!
       ([\w_\s\*\(\)\[\],:]|&(&)?!|<:?!
       ([\w_\s\*\(\)\[\],:]|&(&)?!|<:?!
       ([\w_\s\*\(\)\[\],:]|&(&)?!|<:?!
       ([\w_\s\*\(\)\[\],:]|&(&)?!|<:?!
       ([\w_\s\*\(\)\[\],:]|&(&)?!)*
      >>?!)*>>?!)*>>?!)*>>?!)*>>?!)*>>?!
     /xs
    ]]>
   </start>
   <end match='/(&gt;)/' region0="def:PairEnd" region1="c:StructureSymbol"/>
  </block>

<!--
    <![CDATA[
     /([\w\s])?#1
      (<)(<)?!
      \M(([\w_\s\*\n\r,:]|&(&)?!)|
      (<(([\w_\s\*\n\r,:]|&(&)?!)|
      (<(([\w_\s\*\n\r,:]|&(&)?!)|
      (<(([\w_\s\*\n\r,:]|&(&)?!)|
      (<(([\w_\s\*\n\r,:]|&(&)?!)|
      (<(([\w_\s\*\n\r,:]|&(&)?!))*>)
      )*>))*>))*>))*>))*>
     /xs
    ]]>

-->
  <inherit scheme="AFX-block"/>

  <!-- c++ keywords -->

  <!-- EE: now we don't need it...
  regexp match="/^\s*(private|protected|public)(:)/"
   region1="c:KeywordANSI" region2="c:Label"
  /-->
  <inherit scheme="cpp-qt-label"/>

  <keywords region="c:KeywordANSI">
   <word name="and"/>
   <word name="and_eq"/>
   <word name="bitand"/>
   <word name="bitor"/>
   <word name="bool" region="c:KeywordANSI.typenames"/>
   <word name="catch"/>
   <word name="compl"/>
   <word name="const_cast"/>
   <word name="class"/>
   <word name="delete"/>
   <word name="dynamic_cast"/>
   <word name="false"/>
   <word name="friend"/>
   <word name="mutable"/>
   <word name="namespace"/>
   <word name="new"/>
   <word name="not"/>
   <word name="not_eq"/>
   <word name="operator"/>
   <word name="or"/>
   <word name="or_eq"/>
   <word name="offsetof"/>
   <word name="private"/>
   <word name="protected"/>
   <word name="public"/>
   <word name="reinterpret_cast"/>
   <word name="static_cast"/>
   <word name="template"/>
   <word name="this"/>
   <word name="throw"/>
   <word name="true"/>
   <word name="try"/>
   <word name="typeid"/>
   <word name="typename"/>
   <word name="virtual"/>
   <word name="xor"/>
   <word name="xor_eq"/>
   <word name="__based"/>
   <word name="__novtordisp"/>
   <word name="__self"/>
   <word name="__single_inheritance"/>
   <word name="__uuidof"/>
   <word name="__virtual_inheritance"/>

   <word name="nullptr"/>
  </keywords>


  <inherit scheme="c:Expression">
   <virtual scheme="c:Expression" subst-scheme="Expression"/>
  </inherit>
  <inherit scheme="cpp-qt"/>
  
  <inherit scheme="Keywords-STL"/>
 </scheme>
 
 <scheme name="cpp-qt" if='qt-defines'>
  <inherit scheme="cpp-qt:Expression"/>
 </scheme>
 
 <scheme name="cpp-qt-label" if='qt-defines'>
  <inherit scheme="cpp-qt:Labels"/>
 </scheme>
 
 
 

 <scheme name="AFX-block" if="afx-defines">
  <!-- paired block -->
  <block start="/(\/\/\{\{AFX.*)/" end="/(\/\/\}\}AFX.*)/" scheme="def:Comment"
         region="def:CommentContent" region00="def:PairStart" region10="def:PairEnd" region01="def:Comment" region11="def:Comment"/>
 </scheme>

 <scheme name="Keywords-STL" if="stl-defines">
<!-- !!EE (add keywords): STL  -->
  <keywords region="KeywordSTL">
   <word name="std" region="KeywordNamespace"/>

   <!-- c++11 -->
   <word name="move"/>
   <word name="unordered_map"/>
   <word name="unique_ptr"/>
   <word name="shared_ptr"/>
   <word name="weak_ptr"/>
   <!--       -->
   <word name="vector"/>
   <word name="list"/>
   <word name="set"/>
   <word name="multiset"/>
   <word name="map"/>
   <word name="multimap"/>
   <word name="hash_map"/>
   <word name="deque"/>
   <word name="stack"/>
   <word name="queue"/>
   <word name="priority_queue"/>
   <word name="string"/>
   <word name="array"/>
   <word name="valarray"/>
   <word name="biset"/>

   <word name="char_traits"/>
   <word name="basic_string"/>
   <word name="npos" region="c:KeywordConstant"/>

   <word name="ios_base"/>
   <word name="ios"/>
   <word name="basic_ios"/>
   <word name="locate"/>
   <word name="basic_iostream"/>
   <word name="basic_streambuf"/>
   <word name="iostream"/>
   <word name="streambuf"/>
   <word name="istream"/>
   <word name="ostream"/>
   <word name="ifstream"/>
   <word name="ofstream"/>
   <word name="fstream"/>
   <word name="istringstream"/>
   <word name="ostringstream"/>
   <word name="stringstream"/>
   <word name="cout"/>
   <word name="cerr"/>
   <word name="clog"/>
   <word name="cin"/>
   
   <word name="endl"/>
   <word name="ends"/>
   <word name="resetiosflags"/>
   <word name="setbase"/>
   <word name="setfill"/>
   <word name="setiosflags"/>
   <word name="setprecision"/>
   <word name="setw"/>

   <word name="iterator"/>
   <word name="const_iterator"/>
   <word name="input_iterator"/>
   <word name="output_iterator"/>
   <word name="insert_iterator"/>
   <word name="front_insert_iterator"/>
   <word name="back_insert_iterator"/>
   <word name="reverse_iterator"/>
   <word name="const_reverse_iterator"/>
   <word name="istream_iterator"/>
   <word name="ostream_iterator"/>
   <word name="refrence"/>
   <word name="pointer"/>
   <word name="const_refrence"/>
   <word name="const_pointer"/>

   <word name="raw_storage_iterator"/>
   <word name="allocator"/>
   <word name="auto_ptr"/>
   <word name="pair"/>

   <!-- alogoritms -->
   <word name="for_each"/>
   <word name="find"/>
   <word name="find_if"/>
   <word name="find_end"/>
   <word name="find_first_of"/>
   <word name="adjacent_find"/>
   <word name="count"/>
   <word name="count_if"/>
   <word name="mismatch"/>
   <word name="equal"/>
   <word name="search"/>
   <word name="search_n"/>
   <word name="transform"/>
   <word name="copy"/>
   <word name="copy_backward"/>
   <word name="swap"/>
   <word name="iter_swap"/>
   <word name="swap_ranges"/>
   <word name="replace"/>
   <word name="replace_if"/>
   <word name="replace_copy"/>
   <word name="replace_copy_if"/>
   <word name="fill"/>
   <word name="fill_n"/>
   <word name="generate"/>
   <word name="generate_n"/>
   <word name="remove"/>
   <word name="remove_if"/>
   <word name="remove_copy"/>
   <word name="remove_copy_if"/>
   <word name="unique"/>
   <word name="unique_copy"/>
   <word name="reverse"/>
   <word name="reverse_copy"/>
   <word name="rotate"/>
   <word name="rotate_copy"/>
   <word name="random_shuffle"/>
   <word name="sort"/>
   <word name="stable_sort"/>
   <word name="partial_sort"/>
   <word name="partial_sort_copy"/>
   <word name="lower_bound"/>
   <word name="upper_bound"/>
   <word name="equal_range"/>
   <word name="binary_search"/>
   <word name="merge"/>
   <word name="inplace_merge"/>
   <word name="partition"/>
   <word name="stable_partition"/>
   <word name="includes"/>
   <word name="set_union"/>
   <word name="set_intersection"/>
   <word name="set_difference"/>
   <word name="set_symmetric_difference"/>
   <word name="make_heap"/>
   <word name="push_heap"/>
   <word name="pop_heap"/>
   <word name="sort_heap"/>
   <word name="min"/>
   <word name="max"/>
   <word name="min_element"/>
   <word name="max_element"/>
   <word name="lexicogarfical_compare"/>
   <word name="next_permutation"/>
   <word name="prev_permutation"/>

   <word name="equal_to"/>
   <word name="not_equal_to"/>
   <word name="greater"/>
   <word name="less"/>
   <word name="greater_equal"/>
   <word name="less_equal"/>
   <word name="logical_and"/>
   <word name="logical_or"/>
   <word name="logical_not"/>
   <word name="plus"/>
   <word name="minus"/>
   <word name="multiples"/>
   <word name="divides"/>
   <word name="modulus"/>
   <word name="negate"/>

   <word name="bind2nd"/>
   <word name="bind1st"/>
   <word name="mem_fun"/>
   <word name="mem_fun_t"/>
   <word name="const_mem_fun_t"/>
   <word name="mem_fun_ref"/>
   <word name="mem_fun_ref_t"/>
   <word name="const_mem_fun_ref_t"/>
   <word name="ptr_fun"/>
   <word name="not1"/>
   <word name="not2"/>
   <word name="pointer_to_unary_function"/>
   <word name="pointer_to_binary_function"/>
   <word name="unary_negate"/>
   <word name="binary_negate"/>

   <!-- stdexept -->
   <word name="exception"/>
   <word name="logic_error"/>
   <word name="domain_error"/>
   <word name="out_of_range"/>
   <word name="invalid_argument"/>
   <word name="runtime_error"/>
   <word name="range_error"/>
   <word name="overflow_error"/>
   <word name="underflow_error"/>
   <word name="bad_alloc"/>
   <word name="bad_cast"/>
   <word name="bad_exeption"/>
   <word name="bad_typeid"/>
   <word name="failure"/>
  </keywords>
 </scheme>

 <scheme name="Outlines">
  <annotation>
   <documentation>
     C++ outlines (function, classes).
   </documentation>
  </annotation>

  <!-- Colorer 4:
  <regexp match='/^ \M \s* (typedef)?! (\w[\w_*&amp;&lt;&gt;,~:]+ \s
   [\s\w_*&amp;&lt;&gt;,~\":]*?)? (([\:\w_*&amp;~]+?)|(operator..?)
   (\sfor)?~4 (\sif)?~3 (\swhile)?~6 (\sswitch)?~7 (\scatch)?~6 )
   \s* (\([^\)]*?\) (\s*\:\s*[^;]*?)|([^;,&gt;]*?) ) | ( \([^\);]*?) ($|\{)/x'
    region3="cFunc"/>-->

  <regexp><![CDATA[
    /^ \M \s* (typedef)?!
    (\w[\w_*&<>~,:]+ \s [\s\w_*&<>~\",:]*?)?

    (?{c:FuncOutline}
     ([\w_][\w_<*&,\s:>]*?\:\:)? ([\:\w_&*~<>]+?|operator..?)
    )

    (\sfor)?~4 (\sif)?~3 (\swhile)?~6 (\sswitch)?~7 (\scatch)?~6
    \s* \( [^;]* ($|\{)/x  
  ]]></regexp>
<!--
   Ф'ция(...) дальше ": ..."      или не';,<'    или скобки переносятся
   (Это было описание предпоследней строки регэкспа)
-->

  <!--Colorer 4:
  <regexp match='/^ \M \s* ( ((typedef\s+)|(template\s*&lt;.*?&gt;\s*))?
   (struct)|(class)|(union) \s+ ([\w_]+) [\w_:\s]* &lt;?.*?&gt;?)
   ((;)?~1$)|(\{)/x' region8="cFunc"/><!-->

  <regexp><![CDATA[
    /^ \M \s*
    ((typedef\s+)|(template\s*<.*?>\s*))?
    (class) \s+ ([\w_]+\s+)?
    (?{ClassOutline}
     [\w_]+\s* ([\:<]([\:\w\s_&|~<,+\/\%*\->]+|$))? ;?!
    )
    ($|\{)/xs
  ]]></regexp>

  <regexp><![CDATA[
    /^ \M \s*
    ((typedef\s+)|(template\s*<.*?>\s*))?
    (struct) \s+
    (?{c:StructOutline}
     [\w_]+\s* ([\:<]([\:\w\s_&|~<,+\/\%*\->]+|$))? ;?!
    )
    ($|\{)/x
  ]]></regexp>
  
  <regexp><![CDATA[
    /^ \M \s*
    ((typedef\s+)|(template\s*<.*?>\s*))?
    (union) \s+
    (?{c:UnionOutline}
     [\w_]+\s* (<([\:\w\s_&|~<,+\/\%*\->]+|$))? ;?!
    )
    ($|\{)/x
  ]]></regexp>
  
  <!--
  <regexp><![CDATA[
    /^ \M \s*
    (typedef\s+)?
    (
     (enum) \s+
     (?{c:EnumOutline} [\w_]+) | (?{c:EnumOutline} enum )
    )\s*;?!
    ($|\{)/x
  ]]></regexp>-->
  
  
  <!-- [\:\w_&~<,>]+ [\w_:<,>\s]*? [^;] -->
  <!-- NamespaceOutline -->
  <regexp><![CDATA[
    /^ \M (using)?~5\s* (namespace) \s+
    (?{NamespaceOutline}
     [\w_]+\s*;?!
    )
    ($|\{)/x
  ]]></regexp>
  

  <inherit scheme="c:SharedOutlines"/>
 </scheme>


 <scheme name="Operators">
  <annotation>
   <documentation>
    ANSI C++ keyword operators.
   </documentation>
   <appinfo> <todo> <![CDATA[
    Not realised now. See annotation/appinfo/todo at c:Operator for more...
   ]]> </todo> </appinfo>
  </annotation>
  <inherit scheme="c:Operators"/>
 </scheme>

 <scheme name="cpp">
  <inherit scheme="c:c">
   <virtual scheme="c:Operators" subst-scheme="Operators"/>
   <virtual scheme="c:Outlines" subst-scheme="Outlines"/>
   <virtual scheme="c:Expression" subst-scheme="Expression"/>
   <virtual scheme="c:c" subst-scheme="cpp"/>
  </inherit>
 </scheme>


</type>

</hrc>
<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is the Colorer Library.
   -
   - The Initial Developer of the Original Code is
   - Cail Lomecb <cail@nm.ru>.
   - Portions created by the Initial Developer are Copyright (C) 1999-2008
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   - Eugene Efremov <4mirror@mail.ru>:
   - Timur Safin <timur@lanit.ru>
   - Vladimir Tarasov <tsoftgroup@chat.ru>
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the LGPL or the GPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK ***** -->
