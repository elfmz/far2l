#include "unicode/uchar.h"
#include "unicode/utypes.h"
#include "unicode/stringoptions.h"
#include "stdio.h"

/// Usage:
/// g++ -O2 ./CharClasses_mk.cpp -o /tmp/CharClasses_mk -licuuc && /tmp/CharClasses_mk > CharClasses.cpp

static bool IsUnstableWidthBlock(int block)
{
	return block == UBLOCK_ARROWS
	 || block == UBLOCK_MATHEMATICAL_OPERATORS
	 || block == UBLOCK_MISCELLANEOUS_TECHNICAL
	 || block == UBLOCK_CONTROL_PICTURES
	 || block == UBLOCK_GEOMETRIC_SHAPES
	 || block == UBLOCK_MISCELLANEOUS_SYMBOLS
	 || block == UBLOCK_COMBINING_DIACRITICAL_MARKS
	 || block == UBLOCK_COMBINING_MARKS_FOR_SYMBOLS
	 || block == UBLOCK_COMBINING_HALF_MARKS
	 || block == UBLOCK_COMBINING_DIACRITICAL_MARKS_SUPPLEMENT
	 || block == UBLOCK_COMBINING_DIACRITICAL_MARKS_EXTENDED
	;
}

template <class FN>
	static void WriteFunc(const char *name, FN fn)
{
	UChar32 c, last = 0x10ffff;
	UChar32 start = 0;
	bool first = true;
	printf("bool %s(wchar_t c)\n", name);
	printf("{\n");
	printf("\treturn ");
	for (c = 1; c <= last + 1; ++c) {
		const bool matched = (c <= last) && fn(c);
		if (matched) {
			if (!start) {
				start = c;
			}

		} else if (start) {
			if (first) {
				first = false;
			} else {
				printf("\t || ");
			}
			if (start + 2 == c) {
				printf("(c == 0x%x || c == 0x%x)\n", (unsigned int)start, (unsigned int)c - 1);
			} else if (start + 1 < c) {
				printf("(c >= 0x%x && c <= 0x%x)\n", (unsigned int)start, (unsigned int)c - 1);
			} else {
				printf("(c == 0x%x)\n", (unsigned int)start);
			}
			start = 0;
		}
	}
	printf("\t;\n");
	printf("}\n\n");
}

int main()
{
//	printf("%u\n", u_getIntPropertyValue(0xcbe, UCHAR_GENERAL_CATEGORY));
//	return -1;
	UChar32 c, last = 0x10ffff;
	UChar32 unstable_start = 0;
	bool first = true;
	printf("// this file autogenerated by IsUnstableWidthChar_mk.cpp\n\n");
	printf("#include <wchar.h>\n\n");

	WriteFunc("IsCharFullWidth", [](wchar_t c)->bool {
		const auto block = u_getIntPropertyValue(c, UCHAR_BLOCK);
		return u_getIntPropertyValue(c, UCHAR_EAST_ASIAN_WIDTH) != 0
				|| block == UBLOCK_ARROWS
				|| block == UBLOCK_MATHEMATICAL_OPERATORS
				|| block == UBLOCK_MISCELLANEOUS_TECHNICAL
				|| block == UBLOCK_CONTROL_PICTURES
				|| block == UBLOCK_GEOMETRIC_SHAPES
				|| block == UBLOCK_MISCELLANEOUS_SYMBOLS;
	});

	WriteFunc("IsCharPrefix", [](wchar_t c)->bool {
		const auto cat = u_getIntPropertyValue(c, UCHAR_GENERAL_CATEGORY);
		return (cat == U_SURROGATE);
	});

	WriteFunc("IsCharSuffix", [](wchar_t c)->bool {
		const auto block = u_getIntPropertyValue(c, UCHAR_BLOCK);
		const auto jt = u_getIntPropertyValue(c, UCHAR_JOINING_TYPE);
		const auto cat = u_getIntPropertyValue(c, UCHAR_GENERAL_CATEGORY);
		return ( (jt != U_JT_NON_JOINING && jt != U_JT_TRANSPARENT)
			|| cat == U_NON_SPACING_MARK || cat == U_COMBINING_SPACING_MARK
			|| IsUnstableWidthBlock(u_getIntPropertyValue(c, UCHAR_BLOCK))
			|| block == UBLOCK_COMBINING_DIACRITICAL_MARKS
			|| block == UBLOCK_COMBINING_MARKS_FOR_SYMBOLS
			|| block == UBLOCK_COMBINING_HALF_MARKS
			|| block == UBLOCK_COMBINING_DIACRITICAL_MARKS_SUPPLEMENT
			|| block == UBLOCK_COMBINING_DIACRITICAL_MARKS_EXTENDED);
	});

	printf("bool IsCharXxxfix(wchar_t c)\n");
	printf("{\n");
	printf("\treturn IsCharPrefix(c) || IsCharSuffix(c);\n");
	printf("}\n");

	printf("bool IsCharUnstableWidth(wchar_t c)\n");
	printf("{\n");
	printf("\treturn IsCharFullWidth(c) || IsCharXxxfix(c);\n");
	printf("}\n");
}
